#pragma once

#include "Graphics/Renderer.h"
#include "Graphics/Color.h"

#include <vector>
#include <unordered_map>
#include <unordered_set>


///
/// \Class		This class creates View instances. It is important to know that every instance
///				will share the same data, whether generated by one of the public methods or
///				passed by the user as a parameter. It is also important to note that the users
///				is responsible for managing their data and make sure they are available for
///				all views created by the same spawner.
///
/// \Note		This class can be seen as an highly coupled factory. In the sense that every produced
///				objects always depend on the factory and the parameters provided by the user to exist. 
///
/// \Attention	The layout position 0 in GLSL shaders is reserved for the vertices' position.
///
/// \Warning	Unless stated otherwise, all the graphics programs and graphics-program input-parameters provided to
///				this class are not copied. They are referenced using pointers. Meaning you are responsible for managing 
///				these data and keep them available (allocated) for this class at all times.	
///				For the sake of performance, this class will not manage any of your data.
///				If you want a simpler behavior, please have a look at the ViewFactory subclasses.
///

namespace Neptune
{
	class  Texture;
	class  View;
	struct Position;

	class ViewSpawner
	{
	public:
		//
		// C O N S T R U C T O R S
		//
		
		ViewSpawner(GraphicsProgram* _pgm);																	/// Creates the spawner with a first graphics-program _pgm


		//
		// D E F A U L T   G E N E R A T E D   M E T H O D S
		//

		virtual ~ViewSpawner()								= default;
		ViewSpawner(const ViewSpawner&)						= delete;
		ViewSpawner(ViewSpawner&&)							= delete;
		virtual ViewSpawner& operator=(const ViewSpawner&)	= delete;
		virtual ViewSpawner& operator=(ViewSpawner&&)		= delete;


		//
		// P U R E   V I R T U A L   M E T H O D S 
		//

		virtual void  createVertexData()				=0;													/// Creates the vertex position data
		virtual bool  createColorData(const Color& _c)	=0;													/// Creates per-vertex color data, if the data were already created, the color will be changed (for all the view instantiated by the factory). The input color for this method is not referenced.
		virtual bool  createNormalData()				=0;													/// Creates the normals at every vertex of the view
		virtual bool  create2DTextureMapData()			=0;													/// Creates the data to be able to map a 2D texture on the whole view


		//
		// C R E A T I O N   M E T H O D S 
		//

		View* create();																						/// Allocates the view on the heap

		//
		// G R A P H I C S - P R O G R A M   R E L A T E D   M E T H O D S 
		//

		void addGraphicsProgram(GraphicsProgram* _pgm);																						/// Add another graphics program, this will add another draw call for the current view
		void addShaderAttribute(GraphicsProgram::ProgramName  _pgmName, const GraphicsProgram::ShaderAttribute& _shaderAtt);				/// Add the shader attribute  _shaderAtt as an input for the program _pgmName. 
		void addUniformVariable(GraphicsProgram::ProgramName  _pgmName, const GraphicsProgram::UniformVarInput& _uniform);					/// Add the uniform variable _uniform as an input for the program _pgmName. The data is copied.
		
		/// \brief Adds the texture  _texture as a texture input for the program _pgmName. 
		/// If two textures in the same program have the same index, _texture replaces it.
		/// \warning In case two textures are swapped (i.e. same index in same program), the swap
		/// will affect ALL instances created by the spawner (even before the actual swap). 
		/// Remember ViewSpawners act like proxies between views and their data (they set 
		/// everything up to render a view).
		void setTexture(GraphicsProgram::ProgramName _pgmName, Texture* _texture);
		
		///
		/// \brief Add the uniform to share for all programs in _pgmNameList. The variable is therefore COPIED only once in memory.
		/// \note  Make sure that the uniform variable's name is the same across all the shaders used by the programs in _pgmNameList.
		///        If it is not the case, an assert is guaranteed to be raised by the Renderer class in Debug config.
		/// \warning not well tested yet
		///
		void addUniformVariable(GraphicsProgram::ProgramName* _pgmNameList, u32 _nbPgm, const GraphicsProgram::UniformVarInput& _uniform);
		
		bool mapVertexData		(  GraphicsProgram::ProgramName _pgmName, u8 _layout);														/// Add the spawner's vertex data as an input for the program _pgmName at GLSL layout position _layout
		bool mapColorData       (  GraphicsProgram::ProgramName _pgmName, u8 _layout);														/// Add the spawner's color data as an input for the program _pgmName at GLSL layout position _layout
		bool mapNormalData      (  GraphicsProgram::ProgramName _pgmName, u8 _layout);														/// Add the spawner's normal data as an input for the program _pgmName at GLSL layout position _layout
		bool map2DTextureMapData(  GraphicsProgram::ProgramName _pgmName, u8 _layout);														/// Add the spawner's 2d texture map coordinates as an input for the program _pgmName at GLSL layout position _layout

		void setWorldPosition(const Position& _pos);																						/// Changes the spawn position for every View to position _pos. The position is expressed in world coordinates.
		void useModelViewAndProjectionMatrices (GraphicsProgram::ProgramName _pgmName);															/// Use a world matrix for the program _pgmName, set with the values from setWorldPosition. It is passed as an uniform variable with the name _uniformName.

		/// \brief Set all graphics programs' parameters (shader attributes, uniform variables...)
		/// then flushes them from programs' shader attribute tables and other parameter tables.
		/// This because the parameters have already been bound to the program.
		/// \note Parameter data are not directly given to programs to allow parameter sharing between them.
		void movePgmParameters();

	protected:
		
		//
		// P U R E   V I R T U A L   M E T H O D S 
		//

		/// \brief In this method you must dynamically allocate a View object
		/// (called v). Then call v->getRenderer().setDrawingPrimitive(_prim)  
		/// and v->getRenderer().setNbverticesToRender(nb).
		virtual View* createViewAndSetUpRenderParameters()	=0;


		//
		// A T T R I B U T E S
		//

		std::vector<float>								m_vertices;
		std::vector<Color>								m_colors;
		std::vector<float>								m_2DTexCoords;
		std::vector<float>								m_normals;
		float											m_worldMatrix[4][4];								/// Initial position (in world coordinates) for every View generated by the spawner. 

	private:

		typedef u64 UniformVariableID; // Combination of two 32-bit hashes: 0x pgm_name uniform_name (little endian example)

		//
		// S T R U C T U R E S
		//

		struct Program
		{
			///
			/// \struct Used to locate a shader attribute in the shader-attribute table 
			/// and adapt its content to fit the program's needs.
			///
			struct CustomShaderAttributeData
			{
				const void*	m_id;		/// Attribute's position in m_shaderAttributes
				u8			m_layout;	/// Its layout in its shader. Saved here so that one same shader input is shared for every program.  
			};

			GraphicsProgram*								m_program;
			std::vector<const CustomShaderAttributeData>	m_shaderAttributesCustomData;	/// Attributes' custom data (NOTE: contains attributes' position in the shader-attribute table)
			std::vector<UniformVariableID>					m_uniformVarIDs;				/// Uniform variables' position in m_uniformVariables
			std::unordered_map<u32, Texture*>				m_textures;					/// Textures' position in m_textures. The key is the texture's ID to enable texture swap.
		};


		//
		// A T T R I B U T E S
		//

		std::unordered_map<GraphicsProgram::ProgramName, Program>				m_programs;				/// Contains all the programs to be used to render the views
		std::unordered_map<const void*, GraphicsProgram::ShaderAttribute>		m_shaderAttributes;		/// Stores all shader attributes for all programs (aka the shader-attribute table). The void* is the address of the buffer containing the data (m_data field).
		std::unordered_map<UniformVariableID, GraphicsProgram::UniformVarInput>	m_uniformVariables;		/// Stores all uniform variables for all programs. The void* is the address of the buffer containing the data (m_data field).
	};
}